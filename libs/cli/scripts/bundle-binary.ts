/**
 * Bundle deepagents-cli into a standalone binary using PyInstaller
 */

import * as path from "node:path";
import {
  log,
  logStep,
  execWithOutput,
  ensureDir,
  exists,
  writeFile,
  getPipPath,
  getPyInstallerPath,
  formatDuration,
  type PlatformConfig,
} from "./utils.js";

/**
 * Options for bundling
 */
export interface BundleOptions {
  /** Path to the virtual environment */
  venvDir: string;
  /** Output directory for the binary */
  outputDir: string;
  /** Platform configuration */
  platform: PlatformConfig;
  /** Enable UPX compression */
  useUpx?: boolean;
  /** One file mode (slower startup, smaller distribution) */
  oneFile?: boolean;
}

/**
 * Convert JavaScript boolean to Python boolean string
 */
function pyBool(value: boolean): string {
  return value ? "True" : "False";
}

/**
 * Generate PyInstaller spec file content
 */
function generateSpecFile(options: BundleOptions): string {
  const { venvDir, platform, oneFile = false } = options;

  // Determine the site-packages path pattern
  const isWindows = platform.os === "win32";
  const sitePackagesGlob = isWindows
    ? `${venvDir.replace(/\\/g, "/")}/Lib/site-packages`
    : `${venvDir}/lib/python*/site-packages`;

  return `# -*- mode: python ; coding: utf-8 -*-
"""
PyInstaller spec file for deepagents-cli
Generated by deepagents-cli npm package build script
"""

import glob
import os
import sys

# Find site-packages directory
site_packages_pattern = "${sitePackagesGlob}"
site_packages_dirs = glob.glob(site_packages_pattern)
if not site_packages_dirs:
    raise RuntimeError(f"Could not find site-packages: {site_packages_pattern}")
site_packages = site_packages_dirs[0]

# Entry point
entry_point = os.path.join(site_packages, "deepagents_cli", "__main__.py")
if not os.path.exists(entry_point):
    raise RuntimeError(f"Entry point not found: {entry_point}")

# Collect hidden imports
hidden_imports = [
    # Core deepagents modules
    "deepagents",
    "deepagents.backends",
    "deepagents.backends.composite",
    "deepagents.backends.filesystem",
    "deepagents.backends.protocol",
    "deepagents.backends.sandbox",
    "deepagents.backends.state",
    "deepagents.backends.store",
    "deepagents.graph",
    "deepagents.middleware",
    
    # CLI modules
    "deepagents_cli",
    "deepagents_cli.agent",
    "deepagents_cli.agent_memory",
    "deepagents_cli.commands",
    "deepagents_cli.config",
    "deepagents_cli.execution",
    "deepagents_cli.file_ops",
    "deepagents_cli.image_utils",
    "deepagents_cli.input",
    "deepagents_cli.main",
    "deepagents_cli.project_utils",
    "deepagents_cli.shell",
    "deepagents_cli.skills",
    "deepagents_cli.token_utils",
    "deepagents_cli.tools",
    "deepagents_cli.ui",
    
    # Integrations
    "deepagents_cli.integrations",
    "deepagents_cli.integrations.daytona",
    "deepagents_cli.integrations.modal",
    "deepagents_cli.integrations.runloop",
    "deepagents_cli.integrations.sandbox_factory",
    
    # LangChain ecosystem
    "langchain",
    "langchain.chat_models",
    "langchain_core",
    "langchain_openai",
    "langchain_anthropic",
    "langchain_google_genai",
    
    # Dependencies
    "rich",
    "rich.console",
    "rich.markdown",
    "rich.panel",
    "rich.syntax",
    "rich.table",
    "prompt_toolkit",
    "prompt_toolkit.application",
    "prompt_toolkit.key_binding",
    "tavily",
    "requests",
    "dotenv",
    "yaml",
    "yaml",
    "PIL",
    "PIL.Image",
    "markdownify",
    
    # Standard library that may be missed
    "asyncio",
    "json",
    "re",
    "pathlib",
    "typing",
    "dataclasses",
]

# Collect data files
from PyInstaller.utils.hooks import collect_data_files, collect_submodules

datas = []

# Add deepagents_cli data files (like default_agent_prompt.md)
try:
    datas += collect_data_files("deepagents_cli")
except Exception:
    pass

# Add any .md files from deepagents_cli
import glob as glob_module
for md_file in glob_module.glob(os.path.join(site_packages, "deepagents_cli", "*.md")):
    datas.append((md_file, "deepagents_cli"))

# Collect additional submodules
try:
    hidden_imports += collect_submodules("deepagents")
except Exception:
    pass

try:
    hidden_imports += collect_submodules("deepagents_cli")
except Exception:
    pass

# Analysis
a = Analysis(
    [entry_point],
    pathex=[site_packages],
    binaries=[],
    datas=datas,
    hiddenimports=list(set(hidden_imports)),  # Remove duplicates
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[
        # Exclude test modules
        "pytest",
        "pytest_asyncio",
        "pytest_cov",
        "pytest_mock",
        "pytest_socket",
        "pytest_timeout",
        # Exclude development tools
        "mypy",
        "ruff",
        "black",
        "isort",
        # Exclude unused heavy packages
        "matplotlib",
        "numpy.testing",
        "scipy",
        "pandas",
        "IPython",
        "notebook",
        "jupyter",
    ],
    noarchive=False,
    optimize=0,  # Keep docstrings - LangChain tools require them
)

pyz = PYZ(a.pure, a.zipped_data, cipher=None)

${
  oneFile
    ? `
exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name="${platform.binaryName.replace(".exe", "")}",
    debug=False,
    bootloader_ignore_signals=False,
    strip=${pyBool(platform.os !== "win32")},
    upx=${pyBool(options.useUpx ?? true)},
    upx_exclude=[],
    runtime_tmpdir=None,
    console=True,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)
`
    : `
exe = EXE(
    pyz,
    a.scripts,
    exclude_binaries=True,
    name="${platform.binaryName.replace(".exe", "")}",
    debug=False,
    bootloader_ignore_signals=False,
    strip=${pyBool(platform.os !== "win32")},
    upx=${pyBool(options.useUpx ?? true)},
    console=True,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.datas,
    strip=${pyBool(platform.os !== "win32")},
    upx=${pyBool(options.useUpx ?? true)},
    upx_exclude=[],
    name="${platform.binaryName.replace(".exe", "")}",
)
`
}`;
}

/**
 * Install PyInstaller in the virtual environment
 */
async function installPyInstaller(venvDir: string): Promise<void> {
  log("info", "Installing PyInstaller...");

  const pip = getPipPath(venvDir);
  const exitCode = await execWithOutput(
    `"${pip}" install pyinstaller --no-cache-dir`
  );

  if (exitCode !== 0) {
    throw new Error("Failed to install PyInstaller");
  }

  log("success", "PyInstaller installed");
}

/**
 * Run PyInstaller to create the binary
 */
async function runPyInstaller(
  venvDir: string,
  specPath: string,
  outputDir: string
): Promise<void> {
  log("info", "Running PyInstaller (this may take several minutes)...");

  const pyinstaller = getPyInstallerPath(venvDir);
  const distPath = path.join(outputDir, "dist");
  const buildPath = path.join(outputDir, "build");
  const workPath = path.join(outputDir, "work");

  await ensureDir(distPath);
  await ensureDir(buildPath);
  await ensureDir(workPath);

  const command = [
    `"${pyinstaller}"`,
    "--clean",
    "--noconfirm",
    `--distpath "${distPath}"`,
    `--workpath "${workPath}"`,
    `"${specPath}"`,
  ].join(" ");

  const exitCode = await execWithOutput(command, outputDir);

  if (exitCode !== 0) {
    throw new Error("PyInstaller build failed");
  }

  log("success", "PyInstaller build complete");
}

/**
 * Bundle the CLI into a standalone binary
 */
export async function bundleBinary(options: BundleOptions): Promise<string> {
  const { venvDir, outputDir, platform } = options;
  const startTime = Date.now();

  console.log(`\nðŸ”¨ Building binary for ${platform.name}\n`);

  logStep(1, 4, "Installing PyInstaller");
  await installPyInstaller(venvDir);

  logStep(2, 4, "Generating spec file");
  const specContent = generateSpecFile(options);
  const specPath = path.join(outputDir, "deepagents.spec");
  await ensureDir(outputDir);
  await writeFile(specPath, specContent);
  log("debug", `Spec file written to ${specPath}`);

  logStep(3, 4, "Running PyInstaller");
  await runPyInstaller(venvDir, specPath, outputDir);

  logStep(4, 4, "Verifying output");
  const binaryPath = path.join(outputDir, "dist", platform.binaryName);

  const binaryExists = await exists(binaryPath);
  if (!binaryExists) {
    throw new Error(`Binary not found at ${binaryPath}`);
  }

  const duration = Date.now() - startTime;
  log("success", `Binary created in ${formatDuration(duration)}`);
  log("info", `Output: ${binaryPath}`);

  return binaryPath;
}

/**
 * Get the output binary path
 */
export function getBinaryOutputPath(
  outputDir: string,
  platform: PlatformConfig
): string {
  return path.join(outputDir, "dist", platform.binaryName);
}
